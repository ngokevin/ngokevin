<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhml"
      xmlns:fb="http://ogp.me/ns/fb#"
      xml:lang="en" lang="en">

  <head>
    <title>ngokevin | How to Write an A-Frame VR Component</title>
    <link rel="stylesheet" type="text/css" href="/css/bundle.css" />
    <link href='http://fonts.googleapis.com/css?family=Ubuntu:400,500,700' rel='stylesheet' type='text/css'>
    <link rel="icon" type="image/x-icon" href="/img/favicon.ico?v=5"/>
    <meta name="viewport" content="width=device-width">
    
  <link rel="stylesheet" type="text/css" href="/css/page.css" />
  
    <meta property="og:image" content="http://thevrjump.com/assets/img/articles/aframe-system/aframe-example.jpg"/>
  
  <meta property="og:description" content="A-Frame is a WebVR framework that introduces the entity-component system (docs) to the DOM. The entity-component system treats every entity in the scene as a placeholder object which we apply and mix components to in order to add appearance, behavior, and functionality. A-Frame comes with some standard components out of the box like camera, geometry, material, light, or sound. However, people can write, publish, and register their own components to do whatever they want like have entities collide/explode/spawn, be controlled by physics, or follow a path. Today, we&#39;ll be going through how we can write our own A-Frame components. Note: This article is now part of the A-Frame documentation. View the most up-to-date version. Table of Contents What a Component Looks Like From the DOM Under the Hood Defining the Schema Property Types Single-Property Schemas Multiple-Property Schemas Defining the Lifecycle Methods Component.init() - Set Up Component.update(oldData) - Do the Magic Component.remove() - Tear Down Component.tick() - Background Behavior Component.pause() and Component.play() - Stop and Go Boilerplate Examples Line Component Line Component - Skeleton Line Component - Schema Line Component - Update Line Component - Usage What a Component Looks Like A component contains a bucket of data in the form of component properties. This data is used to modify the entity. For example, we might have an engine component. Possible properties might be horsepower or cylinders. Abstract representation of a component by @rubenmueller of thevrjump.com. From the DOM Let&#39;s first see what a component looks like from the DOM. For example, the light component has properties such as type, color, and intensity. In A-Frame, we register and configure a component to an entity using an HTML attribute and a style-like syntax: &lt;a-entity light=&#34;type: point; color: crimson; intensity: 2.5&#34;&gt;&lt;/a-entity&gt; This would give us a light in the scene. To demonstrate composability, we could give the light a spherical representation by mixing in the geometry component. &lt;a-entity geometry=&#34;primitive: sphere; radius: 5&#34; light=&#34;type: point; color: crimson; intensity: 2.5&#34;&gt;&lt;/a-entity&gt; Or we can configure the position component to move the light sphere a bit to the right. &lt;a-entity geometry=&#34;primitive: sphere; radius: 5&#34; light=&#34;type: point; color: crimson; intensity: 2.5&#34; position=&#34;5 0 0&#34;&gt;&lt;/a-entity&gt; Given the style-like syntax and that it modifies the appearance and behavior of DOM nodes, component properties can be thought of as a rough analog to CSS. In the near future, I can imagine component property stylesheets. Under the Hood Now let&#39;s see what a component looks like under the hood. A-Frame&#39;s most basic component is the position component: AFRAME.registerComponent(&#39;position&#39;, { schema: { type: &#39;vec3&#39; }, update: function () { var object3D = this.el.object3D; var data = this.data; object3D.position.set(data.x, data.y, data.z); } }); The position component uses only a tiny subset of the component API, but what this does is register the component with the name &#34;position&#34;, define a schema where the component&#39;s value with be parsed to an {x, y, z} object, and when the component initializes or the component&#39;s data updates, set the position of the entity with the update callback. this.el is a reference from the component to the DOM element, or entity, and object3D is the entity&#39;s three.js. Note that A-Frame is built on top of three.js so many components will be using the three.js API. So we see that components consist of a name and a definition, and then they can be registered to A-Frame. We saw the the position component definition defined a schema and an update handler. Components simply consist of the schema, which defines the shape of the data, and several handlers for the component to modify the entity in reaction to different types of events. Here is the current list of properties and methods of a component definition: Property Description data Data of the component derived from the schema default values, mixins, and the entity&#39;s attributes. el Reference to the entity element. schema Names, types, and default values of the component property value(s). Method Description init Called once when the component is initialized. update Called both when the component is initialized and whenever the component&#39;s data changes (e.g, via setAttribute). remove Called when the component detaches from the element (e.g., via removeAttribute). tick Called on each render loop or tick of the scene. play Called whenever the scene or entity plays to add any background or dynamic behavior. pause Called whenever the scene or entity pauses to remove any background or dynamic behavior. Defining the Schema The component&#39;s schema defines what type of data it takes. A component can either be single-property or consist of multiple properties. And properties have property types. Note that single-property schemas and property types are being released in A-Frame v0.2.0. A property might look like: { type: &#39;int&#39;, default: 5 } And a schema consisting of multiple properties might look like: { color: { default: &#39;#FFF&#39; }, target: { type: &#39;selector&#39; }, uv: { default: &#39;1 1&#39;, parse: function (value) { return value.split(&#39; &#39;).map(parseFloat); } }, } Since components in the entity-component system are just buckets of data that are used to affect the appearance or behavior of the entity, the schema plays a crucial role in the definition of the component. Property Types A-Frame comes with several built-in property types such as boolean, int, number, selector, string, or vec3. Every single property is assigned a type, whether explicitly through the type key or implictly via inferring the value. And each type is used to assign parse and stringify functions. The parser deserializes the incoming string value from the DOM to be put into the component&#39;s data object. The stringifier is used when using setAttribute to serialize back to the DOM. We can actually define and register our own property types: AFRAME.registerPropertyType(&#39;radians&#39;, { parse: function () { } // Default stringify is .toString(). }); Single-Property Schemas If a component has only one property, then it must either have a type or a default value. If the type is defined, then the type is used to parse and coerce the string retrieved from the DOM (e.g., getAttribute). Or if the default value is defined, the default value is used to infer the type. Take for instance the visible component. The schema property definition implicitly defines it as a boolean: AFRAME.registerComponent(&#39;visible&#39;, { schema: { // Type will be inferred to be boolean. default: true }, // ... }); Or the rotation component which explicitly defines the value as a vec3: AFRAME.registerComponent(&#39;rotation&#39;, { schema: { // Default value will be 0, 0, 0 as defined by the vec3 property type. type: &#39;vec3&#39; } // ... }); Using these defined property types, schemas are processed by registerComponent to inject default values, parsers, and stringifiers for each property. So if a default value is not defined, the default value will be whatever the property type defines as the &#34;default default value&#34;. Multiple-Property Schemas If a component has multiple properties (or one named property), then it consists of one or more property definitions, in the form described above, in an object keyed by property name. For instance, a physics body component might define a schema: AFRAME.registerComponent(&#39;physics-body&#39;, { schema: { boundingBox: { type: &#39;vec3&#39;, default: { x: 1, y: 1, z: 1 } }, mass: { default: 0 }, velocity: { type: &#39;vec3&#39; } } } Having multiple properties is what makes the component take the syntax in the form of physics=&#34;mass: 2; velocity: 1 1 1&#34;. With the schema defined, all data coming into the component will be passed through the schema for parsing. Then in the lifecycle methods, the component has access to this.data which in a single-property schema is a value and in a multiple-propery schema is an object. Defining the Lifecycle Methods Component.init() - Set Up init is called once in the component&#39;s lifecycle when it is mounted to the entity. init is generally used to set up variables or members that may used throughout the component or to set up state. Though not every component will need to define an init handler. Sort of like the component-equivalent method to createdCallback or React.ComponentDidMount. For example, the look-at component&#39;s init handler sets up some variables: init: function () { this.target3D = null; this.vector = new THREE.Vector3(); }, // ... Example uses of init by some of the standard A-Frame components: Component Usage camera Create and set a THREE.PerspectiveCamera on the entity. cursor Attach event listeners. light Register light to the lighting system. look-at Create a helper vector. material Set up variables, mainly to visualize the state of the component. wasd-controls Set up an object to keep track of pressed keys. Bind methods. Component.update(oldData) - Do the Magic The update handler is called both at the beginning of the component&#39;s lifecycle with the initial this.data and every time the component&#39;s data changes (generally during the entity&#39;s attributeChangedCallback like with a setAttribute). The update handler gets access to the previous state of the component data passed in through oldData. The previous state of the component can be used to tell exactly which properties changed to do more granular updates. The update handler uses this.data to modify the entity, usually interacting with three.js APIs. One of the simplest update handlers is the visible component&#39;s: update: function () { this.el.object3D.visible = this.data; } A slightly more complex update handler might be the light component&#39;s, which we&#39;ll show via abbreviated code: update: function (oldData) { var diffData = diff(data, oldData || {}); if (this.light &amp;&amp; !(&#39;type&#39; in diffData)) { // If there is an existing light and the type hasn&#39;t changed, update light. Object.keys(diffData).forEach(function (property) { light[property] = diffData[property]; }); } else { // No light exists yet or the type of light has changed, create a new light. this.light = this.getLight(this.data)); // Register the object3D of type `light` to the entity. this.el.setObject3D(&#39;light&#39;, this.light); } } The entity&#39;s object3D is a plain THREE.Object3D. Other three.js object types such as meshes, lights, and cameras can be set with setObject3D where they will be appeneded to the entity&#39;s object3D. Example uses of update by some of the standard A-Frame components: Component Usage camera Set THREE.PerspectiveCamera object properties such as aspect ratio, fov, or near/far clipping planes. look-at Set or update target entity to track the position of. material If component is just attaching, create a material. If shader has not changed, update material. If shader has changed, replace the material. wasd-controls Update the position based on the current velocity. Update the velocity based on the keys pressed. Component.remove() - Tear Down The remove handler is called when the component detaches from the entity such as with removeAttribute. This is generally used to remove all modifications, listeners, and behaviors to the entity that the component added. For example, when the light component detaches, it removes the light it previously attached from the entity and thus the scene: remove: function () { this.el.removeObject3D(&#39;light&#39;); } Example uses of remove by some of the standard A-Frame components: Component Usage camera Remove the THREE.PerspectiveCamera from the entity. geometry Set a plain THREE.Geometry on the mesh. material Set a default THREE.MeshBasicMaterial on the mesh and unregister material from the system. wasd-controls Remove keydown and keyup listeners. Component.tick(time) - Background Behavior The tick handler is called on every single tick or render loop of the scene. So expect it to run on the order of 60-120 times for second. The global uptime of the scene in seconds is passed into the tick handler. For example, the look-at component, which instructs an entity to look at another target entity, uses the tick handler to update the rotation in case the target entity changes its position: tick: function (t) { // target3D and vector are set from the update handler. if (this.target3D) { this.el.object3D.lookAt(this.vector.setFromMatrixPosition(target3D.matrixWorld)); } } Example uses of tick by some of the standard A-Frame components: Component Usage look-at Update rotation of entity to face towards tracked target, in case the target is moving. physics Update the physics world simulation. wasd-controls Use current velocity to move the entity (generally the camera), update velocity if keys are pressed. Component.pause() and Component.play() - Stop and Go To support pause and play, just as with a video game or to toggle entities for performance, components can implement play and pause handlers. These are invoked when the component&#39;s entity runs its play or pause method. When an entity plays or pauses, all of its child entities are also played or paused. Components should implement play or pause handlers if they register any dynamic, asynchronous, or background behavior such as animations, event listeners, or tick handlers. For example, the look-controls component simply removes its event listeners such that the camera does not move when the scene is paused, and it adds its event listeners when the scene starts playing or is resumed: pause: function () { this.removeEventListeners() }, play: function () { this.addEventListeners() } Example uses of pause and play by some of the standard A-Frame components: Component Usage sound Pause/play sound. wasd-controls Remove/attach event listeners. Boilerplate I suggest that people start off with my component boilerplate, even hardcore tool junkies. This will get you straight into building a component and comes with everything you will need to publish your component into the wild. The boilerplate handles creating a stubbed component, build steps for both NPM and browser distribution files, and publishing to Github Pages. Generally with boilerplates, it is better to start from scratch and build your own boilerplate, but the A-Frame component boilerplate contains a lot of tribal inside knowledge about A-Frame and is updated frequently to reflect new things landing on A-Frame. The only possibly opinionated pieces about the boilerplate is the development tools it internally uses that are hidden away by NPM scripts. Examples Line Component Let&#39;s go through building a basic complete component, a line component. This line component will simply render a line. We will make it the component flexible to be able to specify the vertices and color. Play with this example line component in Codepen. Line Component - Skeleton Here is a high-level view of the skeleton of the component, without the meat. For this component, we&#39;ll need the schema, as all components require, the update handler, and the remove handler. The rest of the lifecycle method handlers aren&#39;t necessary. var coordinates = AFRAME.utils.coordinates; AFRAME.registerComponent(&#39;line&#39;, { // Allow line component to accept vertices and color. schema: {}, // Create or update the line geometry. update: {}, // Remove the line geometry. remove: {} }); Line Component -Schema Since we have two properties we want to accept, color and path, we will need a multi-property schema. The color property will just be a simple string that will be fed to THREE.Color which does a lot of work for us. The path property will need a custom property type to parse an array of vec3s. That property type does not exist as a built-in type yet, but we can define an inline parse and stringifier. // Allow line component to accept vertices and color. schema: { color: { default: &#39;#333&#39; }, path: { default: [ { x: -0.5, y: 0, z: 0 }, { x: 0.5, y: 0, z: 0 } ], // Deserialize path in the form of comma-separated vec3s: `0 0 0, 1 1 1, 2 0 3`. parse: function (value) { return value.split(&#39;,&#39;).map(coordinates.parse); }, // Serialize array of vec3s in case someone does // setAttribute(&#39;line&#39;, &#39;path&#39;, [...]). stringify: function (data) { return data.map(coordinates.stringify).join(&#39;,&#39;); } } }, //... The component API is entirely up to us. If we wanted the path to take a different syntax or abstract it further such that it maybe only accepts a starting point and a length and handle the math for the developer, that is our perogative to permissionlessly implement. The schema will handle the shape of the data so by the time it gets to the lifecycle handlers, it will be in a nice data structure. Line Component - Update The update handler is called both on component attach and on the entity&#39;s attributeChangedCallback. In the update for the line component, we want to reate a line geometry if it doesn&#39;t exist yet, or update it if it does. We can create a line in three.js by combining a THREE.LineBasicMaterial and THREE.Geometry and manually pushing vertices. update: function (oldData) { // Set color with material. var material = new THREE.LineBasicMaterial({ color: this.data.color }); // Add vertices to geometry. var geometry = new THREE.Geometry(); this.data.path.forEach(function (vec3) { geometry.vertices.push( new THREE.Vector3(vec3.x, vec3.y, vec3.z) ); }); // Apply mesh. this.el.setObject3D(&#39;mesh&#39;, new THREE.Line(geometry, material)); }, // ... For simplicity, we can just update the line by completely replacing it. In other components, we might want to more granularly update objects for performance. When we set the object with setObject3D, we specify the object type. In this case, it is a mesh, which is a geometry combined with a material. Other object types might be light or camera. setObject3D just puts the object into a map and appends the object under the entity&#39;s scene graph (THREE.Group). Line Component - Remove For removal, we can just use removeObject3D: remove: function () { this.el.removeObject3D(&#39;mesh&#39;); } This will remove the object from the entity&#39;s scene graph. Line Component - Usage Then we with the line component written and registered, we can use it in HTML: &lt;a-scene&gt; &lt;a-assets&gt; &lt;a-mixin id=&#34;red&#34; line=&#34;color: #E20049&#34;&gt;&lt;/a-mixin&gt; &lt;/a-assets&gt; &lt;a-entity id=&#34;happy-face&#34; position=&#34;0 2 -10&#34;&gt; &lt;a-entity mixin=&#34;red&#34; line=&#34;path: -1 1 0, -1 0.5 0, -1 0 0&#34;&gt;&lt;/a-entity&gt; &lt;a-entity mixin=&#34;red&#34; line=&#34;path: 1 1 0, 1 0.5 0, 1 0 0&#34;&gt;&lt;/a-entity&gt; &lt;a-entity mixin=&#34;red&#34; line=&#34;path: -2 -1 0, 0 -2 0, 2 -1&#34;&gt;&lt;/a-entity&gt; &lt;/a-entity&gt; &lt;a-sky color=&#34;#FFEED0&#34;&gt;&lt;/a-sky&gt; &lt;/a-scene&gt; And voila! Happy face with the line component! Play with it on Codepen."/>

  </head>

  <body>
    <div id="wrap" class="c">
      <header>
        <div class="logos">
          <h1 id="logo">
            <a href='/'>ngo<strong>kevin</strong></a>
            <span class="social">
              <a href="mailto:me@ngokevin.com"><i class="fa fa-envelope"></i></a>
              <a href="http://twitter.com/andgokevin"><i class="fa fa-twitter-square"></i></a>
              <a href="http://github.com/ngokevin"><i class="fa fa-github-square"></i></a>
              <a type="application/rss+xml" href="/rss"><i class="fa fa-rss-square"></i></a>
            </span>
          </h1>
          <span id="sublogo">virtual reality developer at mozilla</span>
          <ul class="blog-tags">
            
              <li>
                <a href="/blog/tags/code/"
                   >
                  Code</a>
              </li>
            
              <li>
                <a href="/blog/tags/life/"
                   >
                  Life</a>
              </li>
            
              <li>
                <a href="/blog/tags/photography/"
                   >
                  Shoot</a>
              </li>
            
              <li>
                <a href="/blog/tags/poker/"
                   >
                  Poker</a>
              </li>
            
          </ul>
        </div>

        <nav>
          
            <a href="/about/">
              <span>
                About</span>
            </a>
          
            <a href="/">
              <span>
                Write</span>
            </a>
          
            <a href="/photography/">
              <span>
                Shoot</span>
            </a>
          
        </nav>
      </header>

      <div class="main">
        <div class="header-group">
  <div class="blog">
    <h1>How to Write an A-Frame VR Component</h1>

    <p class="metadata">
      
        Sunday January 17, 2016
      
    </p>
  </div>

  <div id="top-share" class="addthis_toolbox addthis_default_style">
  <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
  <a class="addthis_button_tweet"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-513af3cd5e69b4ae"></script>
</div>

        <div class="base-image">
          
            <div class="page_pic ">
              <img class="captioned" src="http://thevrjump.com/assets/img/articles/aframe-system/aframe-example.jpg">
              <div class="page-caption"><span>Abstract representation of components by @rubenmueller of thevrjump.com.</span></div>
            </div>
          
        </div>

        
  <div class="page c">
    <p><a href="/blog/aframe">A-Frame</a> is a WebVR framework that introduces the
<a href="/blog/aframe-vs-3dml">entity-component system</a> (<a href="docs">docs</a>) to the DOM. The
entity-component system treats every <strong>entity</strong> in the scene as a placeholder
object which we apply and mix <strong>components</strong> to in order to add appearance,
behavior, and functionality. A-Frame comes with some standard components out of
the box like camera, geometry, material, light, or sound. However, people can
write, publish, and register their own components to do <strong>whatever</strong> they want
like have entities <a href="https://github.com/dmarcos/a-invaders/tree/master/js/components">collide/explode/spawn</a>, be controlled by
<a href="https://github.com/ngokevin/aframe-physics-components">physics</a>, or <a href="https://jsbin.com/dasefeh/edit?html,output">follow a path</a>. Today, we'll be going through
how we can write our own A-Frame components.</p>
<blockquote>
<p><strong>Note</strong>: This article is now part of the A-Frame documentation. View the most <a href="https://aframe.io/docs/master/core/component.html">up-to-date version</a>.</p>
</blockquote>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#what-a-component-looks-like">What a Component Looks Like</a><ul>
<li><a href="#from-the-dom">From the DOM</a></li>
<li><a href="#under-the-hood">Under the Hood</a></li>
</ul>
</li>
<li><a href="#defining-the-schema">Defining the Schema</a><ul>
<li><a href="#property-types">Property Types</a></li>
<li><a href="#single-property-schemas">Single-Property Schemas</a></li>
<li><a href="#multiple-property-schemas">Multiple-Property Schemas</a></li>
</ul>
</li>
<li><a href="#defining-the-lifecycle-methods">Defining the Lifecycle Methods</a><ul>
<li><a href="#component-init-set-up">Component.init() - Set Up</a></li>
<li><a href="#component-update-olddata-do-the-magic">Component.update(oldData) - Do the Magic</a></li>
<li><a href="#component-remove-tear-down">Component.remove() - Tear Down</a></li>
<li><a href="#component-tick-time-background-behavior">Component.tick() - Background Behavior</a></li>
<li><a href="#component-pause-and-component-play-stop-and-go">Component.pause() and Component.play() - Stop and Go</a></li>
</ul>
</li>
<li><a href="#boilerplate">Boilerplate</a></li>
<li><a href="#examples">Examples</a><ul>
<li><a href="#line-component">Line Component</a><ul>
<li><a href="#line-component-skeleton">Line Component - Skeleton</a></li>
<li><a href="#line-component-schema">Line Component - Schema</a></li>
<li><a href="#line-component-update">Line Component - Update</a></li>
<li><a href="#line-component-usage">Line Component - Usage</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="what-a-component-looks-like">What a Component Looks Like</h2>
<p>A component contains a bucket of data in the form of component properties. This
data is used to modify the entity. For example, we might have an <em>engine</em>
component. Possible properties might be <em>horsepower</em> or <em>cylinders</em>.</p>
<p><img alt="" src="http://thevrjump.com/assets/img/articles/aframe-system/aframe-system.jpg" />
<div class="page-caption"><span>
Abstract representation of a component by @rubenmueller of thevrjump.com.
</span></div></p>
<h3 id="from-the-dom">From the DOM</h3>
<p>Let's first see what a component looks like from the DOM.</p>
<p>For example, the <a href="https://aframe.io/docs/components/light.html">light component</a> has properties such as type, color,
and intensity. In A-Frame, we register and configure a component to an entity
using an HTML attribute and a style-like syntax:</p>
<div class="highlight"><pre><span class="p">&lt;</span><span class="nt">a-entity</span> <span class="na">light</span><span class="o">=</span><span class="s">&quot;type: point; color: crimson; intensity: 2.5&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">a-entity</span><span class="p">&gt;</span>
</pre></div>


<p>This would give us a light in the scene. To demonstrate composability, we could
give the light a spherical representation by mixing in the <a href="https://aframe.io/docs/components/geometry.html">geometry
component</a>.</p>
<div class="highlight"><pre><span class="p">&lt;</span><span class="nt">a-entity</span> <span class="na">geometry</span><span class="o">=</span><span class="s">&quot;primitive: sphere; radius: 5&quot;</span>
          <span class="na">light</span><span class="o">=</span><span class="s">&quot;type: point; color: crimson; intensity: 2.5&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">a-entity</span><span class="p">&gt;</span>
</pre></div>


<p>Or we can configure the position component to move the light sphere a bit to the right.</p>
<div class="highlight"><pre><span class="p">&lt;</span><span class="nt">a-entity</span> <span class="na">geometry</span><span class="o">=</span><span class="s">&quot;primitive: sphere; radius: 5&quot;</span>
          <span class="na">light</span><span class="o">=</span><span class="s">&quot;type: point; color: crimson; intensity: 2.5&quot;</span>
          <span class="na">position</span><span class="o">=</span><span class="s">&quot;5 0 0&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">a-entity</span><span class="p">&gt;</span>
</pre></div>


<p>Given the style-like syntax and that it modifies the appearance and behavior of
DOM nodes, component properties can be thought of as a rough analog to CSS. In
the near future, I can imagine component property stylesheets.</p>
<h3 id="under-the-hood">Under the Hood</h3>
<p>Now let's see what a component looks like <strong>under the hood</strong>. A-Frame's most
basic component is the <a href="https://aframe.io/docs/components/position.html">position component</a>:</p>
<div class="highlight"><pre><span class="nx">AFRAME</span><span class="p">.</span><span class="nx">registerComponent</span><span class="p">(</span><span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">schema</span><span class="o">:</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;vec3&#39;</span> <span class="p">},</span>

  <span class="nx">update</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">object3D</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">object3D</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
    <span class="nx">object3D</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">data</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">data</span><span class="p">.</span><span class="nx">z</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>


<p>The position component uses only a tiny subset of the component API, but what
this does is register the component with the name "position", define a <code>schema</code>
where the component's value with be parsed to an <code>{x, y, z}</code> object, and when
the component initializes or the component's data updates, set the position of
the entity with the <code>update</code> callback. <code>this.el</code> is a reference from the
component to the DOM element, or entity, and <code>object3D</code> is the entity's
<a href="http://threejs.org/">three.js</a>. Note that A-Frame is built on top of three.js so many
components will be using the three.js API.</p>
<p>So we see that components consist of a name and a definition, and then they can
be registered to A-Frame. We saw the the position component definition defined
a <code>schema</code> and an <code>update</code> handler. Components simply consist of the <code>schema</code>,
which defines the shape of the data, and several handlers for the component to
modify the entity in reaction to different types of events.</p>
<p>Here is the current list of properties and methods of a component definition:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>Data of the component derived from the schema default values, mixins, and the entity's attributes.</td>
</tr>
<tr>
<td>el</td>
<td>Reference to the <a href="https://aframe.io/docs/core/entity.html">entity</a> element.</td>
</tr>
<tr>
<td>schema</td>
<td>Names, types, and default values of the component property value(s).</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>init</td>
<td>Called once when the component is initialized.</td>
</tr>
<tr>
<td>update</td>
<td>Called both when the component is initialized and whenever the component's data changes (e.g, via <em>setAttribute</em>).</td>
</tr>
<tr>
<td>remove</td>
<td>Called when the component detaches from the element (e.g., via <em>removeAttribute</em>).</td>
</tr>
<tr>
<td>tick</td>
<td>Called on each render loop or tick of the scene.</td>
</tr>
<tr>
<td>play</td>
<td>Called whenever the scene or entity plays to add any background or dynamic behavior.</td>
</tr>
<tr>
<td>pause</td>
<td>Called whenever the scene or entity pauses to remove any background or dynamic behavior.</td>
</tr>
</tbody>
</table>
<h2 id="defining-the-schema">Defining the Schema</h2>
<p>The component's schema defines what type of data it takes. A component can
either be single-property or consist of multiple properties. And properties
have <em>property types</em>. Note that single-property schemas and property types are
being released in A-Frame <code>v0.2.0</code>.</p>
<p>A property might look like:</p>
<div class="highlight"><pre><span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="k">default</span><span class="o">:</span> <span class="mi">5</span> <span class="p">}</span>
</pre></div>


<p>And a schema consisting of multiple properties might look like:</p>
<div class="highlight"><pre><span class="p">{</span>
  <span class="nx">color</span><span class="o">:</span> <span class="p">{</span> <span class="k">default</span><span class="o">:</span> <span class="s1">&#39;#FFF&#39;</span> <span class="p">},</span>
  <span class="nx">target</span><span class="o">:</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;selector&#39;</span> <span class="p">},</span>
  <span class="nx">uv</span><span class="o">:</span> <span class="p">{</span>
    <span class="k">default</span><span class="o">:</span> <span class="s1">&#39;1 1&#39;</span><span class="p">,</span>
    <span class="nx">parse</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nb">parseFloat</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">},</span>
<span class="p">}</span>
</pre></div>


<p>Since components in the entity-component system are just buckets of data that
are used to affect the appearance or behavior of the entity, the schema plays a
crucial role in the definition of the component.</p>
<h3 id="property-types">Property Types</h3>
<p>A-Frame comes with several built-in property types such as <code>boolean</code>, <code>int</code>,
<code>number</code>, <code>selector</code>, <code>string</code>, or <code>vec3</code>. Every single property is assigned a
type, whether explicitly through the <code>type</code> key or implictly via inferring the
value. And each type is used to assign <code>parse</code> and <code>stringify</code> functions. The
parser deserializes the incoming string value from the DOM to be put into the
component's data object. The stringifier is used when using <code>setAttribute</code> to
serialize back to the DOM.</p>
<p>We can actually define and register our own property types:</p>
<div class="highlight"><pre><span class="nx">AFRAME</span><span class="p">.</span><span class="nx">registerPropertyType</span><span class="p">(</span><span class="s1">&#39;radians&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">parse</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">}</span>

  <span class="c1">// Default stringify is .toString().</span>
<span class="p">});</span>
</pre></div>


<h3 id="single-property-schemas">Single-Property Schemas</h3>
<p>If a component has only one property, then it must either have a <code>type</code> or a
<code>default</code> value. If the type is defined, then the type is used to parse and
coerce the string retrieved from the DOM (e.g., <code>getAttribute</code>). Or if the
default value is defined, the default value is used to infer the type.</p>
<p>Take for instance the <a href="https://aframe.io/docs/components/visible.html">visible component</a>. The schema property
definition implicitly defines it as a boolean:</p>
<div class="highlight"><pre><span class="nx">AFRAME</span><span class="p">.</span><span class="nx">registerComponent</span><span class="p">(</span><span class="s1">&#39;visible&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">schema</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// Type will be inferred to be boolean.</span>
    <span class="k">default</span><span class="o">:</span> <span class="kc">true</span>
  <span class="p">},</span>

  <span class="c1">// ...</span>
<span class="p">});</span>
</pre></div>


<p>Or the <a href="https://aframe.io/docs/components/rotation.html">rotation component</a> which explicitly defines the value as a <code>vec3</code>:</p>
<div class="highlight"><pre><span class="nx">AFRAME</span><span class="p">.</span><span class="nx">registerComponent</span><span class="p">(</span><span class="s1">&#39;rotation&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">schema</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// Default value will be 0, 0, 0 as defined by the vec3 property type.</span>
    <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;vec3&#39;</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">});</span>
</pre></div>


<p>Using these defined property types, schemas are processed by
<code>registerComponent</code> to inject default values, parsers, and stringifiers for
each property. So if a default value is not defined, the default value will be
whatever the property type defines as the "default default value".</p>
<h3 id="multiple-property-schemas">Multiple-Property Schemas</h3>
<p>If a component has multiple properties (or one named property), then it consists of
one or more property definitions, in the form described above, in an object keyed by
property name. For instance, a physics body component might define a schema:</p>
<div class="highlight"><pre><span class="nx">AFRAME</span><span class="p">.</span><span class="nx">registerComponent</span><span class="p">(</span><span class="s1">&#39;physics-body&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">schema</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">boundingBox</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;vec3&#39;</span><span class="p">,</span>
      <span class="k">default</span><span class="o">:</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">z</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">mass</span><span class="o">:</span> <span class="p">{</span>
      <span class="k">default</span><span class="o">:</span> <span class="mi">0</span>
    <span class="p">},</span>
    <span class="nx">velocity</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;vec3&#39;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Having multiple properties is what makes the component take the syntax in the
form of <code>physics="mass: 2; velocity: 1 1 1"</code>.</p>
<p>With the schema defined, all data coming into the component will be passed
through the schema for parsing. Then in the lifecycle methods, the component
has access to <code>this.data</code> which in a single-property schema is a value and in a
multiple-propery schema is an object.</p>
<h2 id="defining-the-lifecycle-methods">Defining the Lifecycle Methods</h2>
<h3 id="componentinit-set-up">Component.init() - Set Up</h3>
<p><code>init</code> is called once in the component's lifecycle when it is mounted to the
entity. <code>init</code> is generally used to set up variables or members that may used
throughout the component or to set up state. Though not every component will
need to define an <code>init</code> handler. Sort of like the component-equivalent method
to <code>createdCallback</code> or <code>React.ComponentDidMount</code>.</p>
<p>For example, the <code>look-at</code> component's <code>init</code> handler sets up some variables:</p>
<div class="highlight"><pre><span class="nx">init</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">target3D</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">vector</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">();</span>
<span class="p">},</span>

<span class="c1">// ...</span>
</pre></div>


<p>Example uses of <code>init</code> by some of the standard A-Frame components:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td>camera</td>
<td>Create and set a THREE.PerspectiveCamera on the entity.</td>
</tr>
<tr>
<td>cursor</td>
<td>Attach event listeners.</td>
</tr>
<tr>
<td>light</td>
<td>Register light to the lighting system.</td>
</tr>
<tr>
<td>look-at</td>
<td>Create a helper vector.</td>
</tr>
<tr>
<td>material</td>
<td>Set up variables, mainly to visualize the state of the component.</td>
</tr>
<tr>
<td>wasd-controls</td>
<td>Set up an object to keep track of pressed keys. Bind methods.</td>
</tr>
</tbody>
</table>
<h3 id="componentupdateolddata-do-the-magic">Component.update(oldData) - Do the Magic</h3>
<p>The <code>update</code> handler is called both at the beginning of the component's
lifecycle with the initial <code>this.data</code> <em>and</em> every time the component's data
changes (generally during the entity's <code>attributeChangedCallback</code> like with a
<code>setAttribute</code>). The update handler gets access to the previous state of the
component data passed in through <code>oldData</code>. The previous state of the component
can be used to tell exactly which properties changed to do more granular
updates.</p>
<p>The update handler uses <code>this.data</code> to modify the entity, usually interacting
with three.js APIs. One of the simplest update handlers is the
<a href="https://aframe.io/docs/components/visible.html">visible</a> component's:</p>
<div class="highlight"><pre><span class="nx">update</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">object3D</span><span class="p">.</span><span class="nx">visible</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>A slightly more complex update handler might be the <a href="https://aframe.io/docs/components/light.html">light</a> component's,
which we'll show via abbreviated code:</p>
<div class="highlight"><pre><span class="nx">update</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">oldData</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">diffData</span> <span class="o">=</span> <span class="nx">diff</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">oldData</span> <span class="o">||</span> <span class="p">{});</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">light</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="s1">&#39;type&#39;</span> <span class="k">in</span> <span class="nx">diffData</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// If there is an existing light and the type hasn&#39;t changed, update light.</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">diffData</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">light</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span> <span class="o">=</span> <span class="nx">diffData</span><span class="p">[</span><span class="nx">property</span><span class="p">];</span>
    <span class="p">});</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// No light exists yet or the type of light has changed, create a new light.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">light</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLight</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">));</span>

    <span class="c1">// Register the object3D of type `light` to the entity.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">setObject3D</span><span class="p">(</span><span class="s1">&#39;light&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">light</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>The entity's <code>object3D</code> is a plain THREE.Object3D. Other three.js object types
such as meshes, lights, and cameras can be set with <code>setObject3D</code> where they
will be appeneded to the entity's <code>object3D</code>.</p>
<p>Example uses of <code>update</code> by some of the standard A-Frame components:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td>camera</td>
<td>Set THREE.PerspectiveCamera object properties such as aspect ratio, fov, or near/far clipping planes.</td>
</tr>
<tr>
<td>look-at</td>
<td>Set or update target entity to track the position of.</td>
</tr>
<tr>
<td>material</td>
<td>If component is just attaching, create a material. If shader has not changed, update material. If shader has changed, replace the material.</td>
</tr>
<tr>
<td>wasd-controls</td>
<td>Update the position based on the current velocity. Update the velocity based on the keys pressed.</td>
</tr>
</tbody>
</table>
<h3 id="componentremove-tear-down">Component.remove() - Tear Down</h3>
<p>The <code>remove</code> handler is called when the component detaches from the entity such
as with <code>removeAttribute</code>. This is generally used to remove all modifications,
listeners, and behaviors to the entity that the component added.</p>
<p>For example, when the <a href="https://aframe.io/docs/components/light.html">light component</a> detaches, it removes the light
it previously attached from the entity and thus the scene:</p>
<div class="highlight"><pre><span class="nx">remove</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">removeObject3D</span><span class="p">(</span><span class="s1">&#39;light&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Example uses of <code>remove</code> by some of the standard A-Frame components:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td>camera</td>
<td>Remove the THREE.PerspectiveCamera from the entity.</td>
</tr>
<tr>
<td>geometry</td>
<td>Set a plain THREE.Geometry on the mesh.</td>
</tr>
<tr>
<td>material</td>
<td>Set a default THREE.MeshBasicMaterial on the mesh and unregister material from the system.</td>
</tr>
<tr>
<td>wasd-controls</td>
<td>Remove keydown and keyup listeners.</td>
</tr>
</tbody>
</table>
<h3 id="componentticktime-background-behavior">Component.tick(time) - Background Behavior</h3>
<p>The <code>tick</code> handler is called on every single tick or render loop of the scene.
So expect it to run on the order of 60-120 times for second. The global uptime of
the scene in seconds is passed into the tick handler.</p>
<p>For example, the <a href="https://aframe.io/docs/components/look-at.html">look-at</a> component, which instructs an entity to
look at another target entity, uses the tick handler to update the rotation in
case the target entity changes its position:</p>
<div class="highlight"><pre><span class="nx">tick</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// target3D and vector are set from the update handler.</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">target3D</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">object3D</span><span class="p">.</span><span class="nx">lookAt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">vector</span><span class="p">.</span><span class="nx">setFromMatrixPosition</span><span class="p">(</span><span class="nx">target3D</span><span class="p">.</span><span class="nx">matrixWorld</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Example uses of <code>tick</code> by some of the standard A-Frame components:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td>look-at</td>
<td>Update rotation of entity to face towards tracked target, in case the target is moving.</td>
</tr>
<tr>
<td>physics</td>
<td>Update the physics world simulation.</td>
</tr>
<tr>
<td>wasd-controls</td>
<td>Use current velocity to move the entity (generally the camera), update velocity if keys are pressed.</td>
</tr>
</tbody>
</table>
<h3 id="componentpause-and-componentplay-stop-and-go">Component.pause() and Component.play() - Stop and Go</h3>
<p>To support pause and play, just as with a video game or to toggle entities for
performance, components can implement <code>play</code> and <code>pause</code> handlers. These are
invoked when the component's entity runs its <code>play</code> or <code>pause</code> method. When an
entity plays or pauses, all of its child entities are also played or paused.</p>
<p>Components should implement play or pause handlers if they register any
dynamic, asynchronous, or background behavior such as animations, event
listeners, or tick handlers.</p>
<p>For example, the <code>look-controls</code> component simply removes its event listeners
such that the camera does not move when the scene is paused, and it adds its
event listeners when the scene starts playing or is resumed:</p>
<div class="highlight"><pre><span class="nx">pause</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">removeEventListeners</span><span class="p">()</span>
<span class="p">},</span>

<span class="nx">play</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">addEventListeners</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>Example uses of <code>pause</code> and <code>play</code> by some of the standard A-Frame components:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td>sound</td>
<td>Pause/play sound.</td>
</tr>
<tr>
<td>wasd-controls</td>
<td>Remove/attach event listeners.</td>
</tr>
</tbody>
</table>
<h2 id="boilerplate">Boilerplate</h2>
<p>I suggest that people start off with my <a href="https://github.com/ngokevin/aframe-component-boilerplate">component boilerplate</a>,
even hardcore tool junkies. This will get you straight into building a
component and comes with everything you will need to publish your component
into the wild. The boilerplate handles creating a stubbed component, build
steps for both NPM and browser distribution files, and publishing to Github
Pages.</p>
<p>Generally with boilerplates, it is better to start from scratch and build your
own boilerplate, but the A-Frame component boilerplate contains a lot of tribal
inside knowledge about A-Frame and is updated frequently to reflect new things
landing on A-Frame. The only possibly opinionated pieces about the boilerplate
is the development tools it internally uses that are hidden away by NPM
scripts.</p>
<h2 id="examples">Examples</h2>
<h3 id="line-component">Line Component</h3>
<p>Let's go through building a basic complete component, a <em>line</em> component. This
line component will simply render a line. We will make it the component
flexible to be able to specify the vertices and color.</p>
<blockquote>
<p>Play with this <a href="https://codepen.io/team/mozvr/pen/yeEQNG">example line component in Codepen</a>.</p>
</blockquote>
<h4 id="line-component-skeleton">Line Component - Skeleton</h4>
<p>Here is a high-level view of the skeleton of the component, without the meat.
For this component, we'll need the <code>schema</code>, as all components require, the
<code>update</code> handler, and the <code>remove</code> handler. The rest of the lifecycle method
handlers aren't necessary.</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">coordinates</span> <span class="o">=</span> <span class="nx">AFRAME</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nx">coordinates</span><span class="p">;</span>

<span class="nx">AFRAME</span><span class="p">.</span><span class="nx">registerComponent</span><span class="p">(</span><span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="c1">// Allow line component to accept vertices and color.</span>
  <span class="nx">schema</span><span class="o">:</span> <span class="p">{},</span>

  <span class="c1">// Create or update the line geometry.</span>
  <span class="nx">update</span><span class="o">:</span> <span class="p">{},</span>

  <span class="c1">// Remove the line geometry.</span>
  <span class="nx">remove</span><span class="o">:</span> <span class="p">{}</span>
<span class="p">});</span>
</pre></div>


<h4 id="line-component-schema">Line Component -Schema</h4>
<p>Since we have two properties we want to accept, <code>color</code> and <code>path</code>, we will
need a multi-property schema. The <code>color</code> property will just be a simple string
that will be fed to <code>THREE.Color</code> which does a lot of work for us. The <code>path</code>
property will need a custom property type to parse an array of <code>vec3</code>s. That
property type does not exist as a built-in type yet, but we can define an
inline parse and stringifier.</p>
<div class="highlight"><pre>  <span class="c1">// Allow line component to accept vertices and color.</span>
  <span class="nx">schema</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">color</span><span class="o">:</span> <span class="p">{</span> <span class="k">default</span><span class="o">:</span> <span class="s1">&#39;#333&#39;</span> <span class="p">},</span>

    <span class="nx">path</span><span class="o">:</span> <span class="p">{</span>
      <span class="k">default</span><span class="o">:</span> <span class="p">[</span>
        <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">z</span><span class="o">:</span> <span class="mi">0</span> <span class="p">},</span>
        <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">z</span><span class="o">:</span> <span class="mi">0</span> <span class="p">}</span>
      <span class="p">],</span>

      <span class="c1">// Deserialize path in the form of comma-separated vec3s: `0 0 0, 1 1 1, 2 0 3`.</span>
      <span class="nx">parse</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">coordinates</span><span class="p">.</span><span class="nx">parse</span><span class="p">);</span>
      <span class="p">},</span>

      <span class="c1">// Serialize array of vec3s in case someone does</span>
      <span class="c1">// setAttribute(&#39;line&#39;, &#39;path&#39;, [...]).</span>
      <span class="nx">stringify</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">data</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">coordinates</span><span class="p">.</span><span class="nx">stringify</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">},</span>

  <span class="c1">//...</span>
</pre></div>


<p>The component API is entirely up to us. If we wanted the path to take a
different syntax or abstract it further such that it maybe only accepts a
starting point and a length and handle the math for the developer, that is our
perogative to permissionlessly implement.</p>
<p>The schema will handle the shape of the data so by the time it gets to the
lifecycle handlers, it will be in a nice data structure.</p>
<h4 id="line-component-update">Line Component - Update</h4>
<p>The <code>update</code> handler is called both on component attach and on the entity's
<code>attributeChangedCallback</code>. In the update for the line component, we want to
reate a line geometry if it doesn't exist yet, or update it if it does. We can
create a line in <code>three.js</code> by combining a <code>THREE.LineBasicMaterial</code> and
<code>THREE.Geometry</code> and manually pushing vertices.</p>
<div class="highlight"><pre><span class="nx">update</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">oldData</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Set color with material.</span>
  <span class="kd">var</span> <span class="nx">material</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">LineBasicMaterial</span><span class="p">({</span>
    <span class="nx">color</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">color</span>
  <span class="p">});</span>

  <span class="c1">// Add vertices to geometry.</span>
  <span class="kd">var</span> <span class="nx">geometry</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Geometry</span><span class="p">();</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">path</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">vec3</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">geometry</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span>
      <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span><span class="nx">vec3</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">vec3</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">vec3</span><span class="p">.</span><span class="nx">z</span><span class="p">)</span>
    <span class="p">);</span>
  <span class="p">});</span>

  <span class="c1">// Apply mesh.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">setObject3D</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">,</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Line</span><span class="p">(</span><span class="nx">geometry</span><span class="p">,</span> <span class="nx">material</span><span class="p">));</span>
<span class="p">},</span>

<span class="c1">// ...</span>
</pre></div>


<p>For simplicity, we can just update the line by completely replacing it. In
other components, we might want to more granularly update objects for
performance.</p>
<p>When we set the object with <code>setObject3D</code>, we specify the object type. In this
case, it is a <code>mesh</code>, which is a geometry combined with a material. Other
object types might be <code>light</code> or <code>camera</code>. <code>setObject3D</code> just puts the object
into a map and appends the object under the entity's scene graph
(<code>THREE.Group</code>).</p>
<h4 id="line-component-remove">Line Component - Remove</h4>
<p>For removal, we can just use <code>removeObject3D</code>:</p>
<div class="highlight"><pre><span class="nx">remove</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">removeObject3D</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>This will remove the object from the entity's scene graph.</p>
<h4 id="line-component-usage">Line Component - Usage</h4>
<p>Then we with the line component written and registered, we can use it in HTML:</p>
<div class="highlight"><pre><span class="p">&lt;</span><span class="nt">a-scene</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">a-assets</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">a-mixin</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;red&quot;</span> <span class="na">line</span><span class="o">=</span><span class="s">&quot;color: #E20049&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">a-mixin</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">a-assets</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">a-entity</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;happy-face&quot;</span> <span class="na">position</span><span class="o">=</span><span class="s">&quot;0 2 -10&quot;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">a-entity</span> <span class="na">mixin</span><span class="o">=</span><span class="s">&quot;red&quot;</span> <span class="na">line</span><span class="o">=</span><span class="s">&quot;path: -1 1 0, -1 0.5 0, -1 0 0&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">a-entity</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">a-entity</span> <span class="na">mixin</span><span class="o">=</span><span class="s">&quot;red&quot;</span> <span class="na">line</span><span class="o">=</span><span class="s">&quot;path: 1 1 0, 1 0.5 0, 1 0 0&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">a-entity</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">a-entity</span> <span class="na">mixin</span><span class="o">=</span><span class="s">&quot;red&quot;</span> <span class="na">line</span><span class="o">=</span><span class="s">&quot;path: -2 -1 0, 0 -2 0, 2 -1&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">a-entity</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">a-entity</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">a-sky</span> <span class="na">color</span><span class="o">=</span><span class="s">&quot;#FFEED0&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">a-sky</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">a-scene</span><span class="p">&gt;</span>
</pre></div>


<p>And voila!</p>
<p><img alt="" src="http://i.imgur.com/icggby2.jpg" />
<div class="page-caption"><span>
  Happy face with the line component! Play with it on <a href="http://codepen.io/team/mozvr/pen/yeEQNG">Codepen</a>.
</span></div></p>
  </div>

  <p class="end-sect">&sect;</p>
  <div id="bottom-share" class="addthis_toolbox addthis_default_style">
  <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
  <a class="addthis_button_tweet"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-513af3cd5e69b4ae"></script>
   <div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'ngokevin'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
           var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
           dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
           (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  <script src="https://cdn.jsdelivr.net/anchorjs/3.0.0/anchor.min.js"></script>
  <script>anchors.add('h2, h3, h4, h5, h6');</script>

      </div>
    </div>

    <div id="footer">
      <a href="mailto:me@ngokevin.com"><i class="fa fa-envelope"></i></a>
      <a href="http://twitter.com/ngokevin_"><i class="fa fa-twitter-square"></i></a>
      <a href="http://github.com/ngokevin"><i class="fa fa-github-square"></i></a>
      <a type="application/rss+xml" href="/rss/index.xml"><i class="fa fa-rss-square"></i></a>
    </div>

     <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29871909-1']);
  _gaq.push(['_trackPageview']);

  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
  </body>
</html>