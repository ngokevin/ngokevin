<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhml"
      xmlns:fb="http://ogp.me/ns/fb#"
      xml:lang="en" lang="en">

  <head>
    <title>ngokevin | Dropdown Component Using Custom Elements (vs. React)</title>
    <link rel="stylesheet" type="text/css" href="/css/bundle.css" />
    <link href='http://fonts.googleapis.com/css?family=Ubuntu:400,500,700' rel='stylesheet' type='text/css'>
    <link rel="icon" type="image/x-icon" href="/img/favicon.ico?v=5"/>
    <meta name="viewport" content="width=device-width">
    
  <link rel="stylesheet" type="text/css" href="/css/page.css" />
  
    <meta property="og:image" content="http://i.imgur.com/zPR4gcE.png"/>
  
  <meta property="og:description" content="We have been building an increasing amount of Custom Elements, or Web Components, over at the Firefox Marketplace (using a polyfill). Custom Elements are a W3C specification that allow you to define your own HTML elements. Using Custom Elements, rather than arbitrary JS, encourages modularity and testability, with portability and reusability being the enticer. Over the last several months, I worked on revamping the UI for the Firefox Marketplace. Part of it was building a custom dropdown element that would allow users to filter apps based on platform compatibility. I wanted it to behave exactly like a &lt;select&gt; element, complete with its interface, but with the full license to style it however I needed. In this post, I&#39;ll go over Custom Elements, introduce an interesting &#34;proxy&#34; pattern to extend native elements, and then compare Custom Elements with the currently reigning Component king, React. Custom Select source code. Building a Custom Element Custom Elements are still in working draft, but there is a nice document.registerElement polyfill. Here is an extremely simple Custom Element that simple wraps a div and defines some interface on the element&#39;s prototype. document.registerElement(&#39;input-wrapper&#39;, { prototype: Object.create(HTMLElement.prototype, { createdCallback: { value: function () { // Called after the component is &#34;mounted&#34; onto the DOM. this.appendChild(document.createElement(&#39;input&#39;)); } }, input: { get: function() { return this.querySelector(&#39;input&#39;); } }, value: { get: function() { return this.input.value; }, set: function(val) { this.input.value = val; } } }) }); var inputWrapper = document.createElement(&#39;input-wrapper&#39;); document.body.appendChild(inputWrapper); We define the interface using Javascript&#39;s Object.create, extending the basic HTMLElement. The element simply wraps an input, and provides a getter and setter on the input&#39;s value. We drop it into the DOM, and it will natively have whatever interface we defined for it. So we could do something like inputWrapper.value = 5 to directly set the inner input&#39;s value. Basic example, but being able to create these native Custom Elements can go far in modular development. Proxy Pattern: Extending the Select Element by Rerouting Interface Now we got a gist of what a Custom Element is, let&#39;s see how we can use it to create a custom dropdown by extending the native &lt;select&gt; element. Here&#39;s an example of how our element will be used in the HTML: &lt;custom-select name=&#34;my-select&#34;&gt; &lt;custom-selected&gt; The current selected option is &lt;custom-selected-text&gt;&lt;/custom-selected-text&gt; &lt;/custom-selected&gt; &lt;optgroup&gt; &lt;option value=&#34;1&#34;&gt;First value&lt;/option&gt; &lt;option value=&#34;2&#34;&gt;Second value&lt;/option&gt; &lt;option value=&#34;3&#34;&gt;Third value&lt;/option&gt; &lt;option value=&#34;4&#34;&gt;Fourth value&lt;/option&gt; &lt;/optgroup&gt; &lt;/mkt-select&gt; What we&#39;ll do in the createdCallback is, if you check the source code, create an actual internal hidden select element, copying the attributes defined on &lt;custom-select&gt;. Then we&#39;ll create &lt;custom-options&gt;, copying the original options into the hidden select. We extend the custom select&#39;s interface to have an attribute pointing to the hidden select like so: select: { // Actual &lt;select&gt; element to proxy to, steal its interface. // Value set in the createdCallback. get: function() { return this._select; }, set: function(select) { copyAttrs(select, this); this._select = select; } }, This will allow our custom element to absorb the functionality of the native select element. All we have to do is implement the entire interface of the select element by routing to the internal select element. function proxyInterface(destObj, properties, methods, key) { // Proxies destObj.&lt;properties&gt; and destObj.&lt;methods&gt;() to // destObj.&lt;key&gt;. properties.forEach(function(prop) { if (Object.getOwnPropertyDescriptor(destObj, prop)) { // Already defined. return; } // Set a property. Object.defineProperty(destObj, prop, { get: function() { return this[key][prop]; } }); }); methods.forEach(function(method) { // Set a method. Object.defineProperty(destObj, method, { value: function() { return this[key][method].call(arguments); } }); }); } proxyInterface(CustomSelectElement.prototype, [&#39;autofocus&#39;, &#39;disabled&#39;, &#39;form&#39;, &#39;labels&#39;, &#39;length&#39;, &#39;multiple&#39;, &#39;name&#39;, &#39;onchange&#39;, &#39;options&#39;, &#39;required&#39;, &#39;selectedIndex&#39;, &#39;size&#39;, &#39;type&#39;, &#39;validationMessage&#39;, &#39;validity&#39;, &#39;willValidate&#39;], [&#39;add&#39;, &#39;blur&#39;, &#39;checkValidity&#39;, &#39;focus&#39;, &#39;item&#39;, &#39;namedItem&#39;, &#39;remove&#39;, &#39;setCustomValidity&#39;], &#39;select&#39;); proxyInterface will &#34;route&#34; the property lookups (the first array), and method calls (the second array) from the custom select element to the internal select element. Then all we need to do is make sure our select element&#39;s value is up-to-date while we interact with our custom select element, then we can do things like customSelectElement.selectedIndex or customSelectElement.checkValidity() without manually implementing the interface. Note we could have simply looped over HTMLSelectElement.prototype rather than manually entering in each property and method name, but unfortunately that doesn&#39;t play well with some older browsers. With all of this, we have a custom select element that is fully stylizable while having all the functionality of a native select element (because it extends it!). Comparing Custom Elements to React I love React and am using it for a couple of projects. How does Custom Elements compare to it? Custom Elements has no answer to React&#39;s JSX template/syntax. In most of our Custom Elements, we have to manually shuffle things around using the native DOM API. JSX is much, much easier. Custom Elements has no data-binding or automatic DOM updates whenever data updates. It&#39;s all imperative with Custom Elements, you have to listen for changes and manually update the DOM. React is, well, reactive. Whenever a component&#39;s state, so does its representation in the DOM. Custom Elements is a bit harder to nest components than React. In React, it&#39;s natural for a component to render a component that renders a component that renders other components. With Custom Elements, it&#39;s a bit difficult to connect components together in a nice heirarchy, and the only communication you get is through Events. Custom Elements, however, is smaller in KB. React is about 26KB after min+gzip whereas a Custom Elements polyfill is maybe a few KB. Though the 26KB might be worth it since you&#39;ll end up writing less code, and you get the performance of virtual DOM diffing. Custom Elements has no answer to React Native. They&#39;re both just as portable, they both can be dropped into any framework. They both have similar interfaces as well in creating components. Although, React is more powerful. In React, I really enjoy keeping data compartmentalized in states and passing down data as props. Loose comparison, but it&#39;s like combining the data-binding and template power of Angular with the ideas of Custom Elements. However, it doesn&#39;t have to be one or the other either. Why not both? React can wrap Custom Elements if you want it to. As always, choose the best tools for the job."/>

  </head>

  <body>
    <div id="wrap" class="c">
      <header>
        <div class="logos">
          <h1 id="logo">
            <a href='/'>ngo<strong>kevin</strong></a>
            <span class="social">
              <a href="mailto:me@ngokevin.com"><i class="fa fa-envelope"></i></a>
              <a href="http://twitter.com/andgokevin"><i class="fa fa-twitter-square"></i></a>
              <a href="http://github.com/ngokevin"><i class="fa fa-github-square"></i></a>
              <a type="application/rss+xml" href="/rss"><i class="fa fa-rss-square"></i></a>
            </span>
          </h1>
          <span id="sublogo">virtual reality developer at mozilla</span>
          <ul class="blog-tags">
            
              <li>
                <a href="/blog/tags/code/"
                   >
                  Code</a>
              </li>
            
              <li>
                <a href="/blog/tags/life/"
                   >
                  Life</a>
              </li>
            
              <li>
                <a href="/blog/tags/photography/"
                   >
                  Shoot</a>
              </li>
            
              <li>
                <a href="/blog/tags/poker/"
                   >
                  Poker</a>
              </li>
            
          </ul>
        </div>

        <nav>
          
            <a href="/about/">
              <span>
                About</span>
            </a>
          
            <a href="/">
              <span>
                Write</span>
            </a>
          
            <a href="/photography/">
              <span>
                Shoot</span>
            </a>
          
        </nav>
      </header>

      <div class="main">
        <div class="header-group">
  <div class="blog">
    <h1>Dropdown Component Using Custom Elements (vs. React)</h1>

    <p class="metadata">
      
        Thursday May 14, 2015
      
    </p>
  </div>

  <div id="top-share" class="addthis_toolbox addthis_default_style">
  <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
  <a class="addthis_button_tweet"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-513af3cd5e69b4ae"></script>
</div>

        <div class="base-image">
          
            <div class="page_pic ">
              <img class="captioned" src="http://i.imgur.com/zPR4gcE.png">
              <div class="page-caption"><span>Dropdowns have never been easier and native.</span></div>
            </div>
          
        </div>

        
  <div class="page c">
    <p>We have been building an increasing amount of <a href="https://developer.mozilla.org/docs/Web/Web_Components/Custom_Elements">Custom
Elements</a>,
or Web Components, over at the <a href="https://marketplace.firefox.com">Firefox
Marketplace</a> (using a
<a href="https://github.com/WebReflection/document-register-element">polyfill</a>). Custom
Elements are a W3C specification that allow you to define your own HTML
elements. Using Custom Elements, rather than arbitrary JS, encourages
modularity and testability, with portability and reusability being the enticer.</p>
<p>Over the last several months, I worked on revamping the UI for the Firefox
Marketplace. Part of it was building a custom dropdown element that would allow
users to filter apps based on platform compatibility. I wanted it to behave
exactly like a <code>&lt;select&gt;</code> element, complete with its interface, but with
the full license to style it however I needed.</p>
<p>In this post, I'll go over Custom Elements, introduce an interesting "proxy"
pattern to extend native elements, and then compare Custom Elements with the
currently reigning Component king, <a href="http://facebook.github.io/react/">React</a>.</p>
<p><a href="https://github.com/mozilla/fireplace/blob/36ed622f6944a375d5d34e836025895fd149e91d/src/media/js/elements/select.js">Custom Select source code</a>.</p>
<h2 id="building-a-custom-element">Building a Custom Element</h2>
<p><a href="http://www.html5rocks.com/en/tutorials/webcomponents/customelements/">Custom
Elements</a>
are still in working draft, but there is a nice <a href="https://github.com/WebReflection/document-register-element">document.registerElement
polyfill</a>. Here
is an extremely simple Custom Element that simple wraps a <code>div</code> and
defines some interface on the element's prototype.</p>
<div class="highlight"><pre><span class="nb">document</span><span class="p">.</span><span class="nx">registerElement</span><span class="p">(</span><span class="s1">&#39;input-wrapper&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">prototype</span><span class="o">:</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">HTMLElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">createdCallback</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">value</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
                <span class="c1">// Called after the component is &quot;mounted&quot; onto the DOM.</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="nx">input</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="nx">value</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">})</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">inputWrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;input-wrapper&#39;</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">inputWrapper</span><span class="p">);</span>
</pre></div>


<p>We define the interface using Javascript's <code>Object.create</code>, extending the
basic <code>HTMLElement</code>. The element simply wraps an input, and provides a
getter and setter on the input's value. We drop it into the DOM, and it will
natively have whatever interface we defined for it. So we could do something
like <code>inputWrapper.value = 5</code> to directly set the inner <code>input</code>'s
value. Basic example, but being able to create these native Custom Elements can
go far in modular development.</p>
<h2 id="proxy-pattern-extending-the-select-element-by-rerouting-interface">Proxy Pattern: Extending the Select Element by Rerouting Interface</h2>
<p>Now we got a gist of what a Custom Element is, let's see how we can use it to
create a custom dropdown by extending the native <code>&lt;select&gt;</code> element.</p>
<p>Here's an example of how our element will be used in the HTML:</p>
<div class="highlight"><pre><span class="p">&lt;</span><span class="nt">custom-select</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;my-select&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">custom-selected</span><span class="p">&gt;</span>
    The current selected option is <span class="p">&lt;</span><span class="nt">custom-selected-text</span><span class="p">&gt;&lt;/</span><span class="nt">custom-selected-text</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">custom-selected</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">optgroup</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;1&quot;</span><span class="p">&gt;</span>First value<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;2&quot;</span><span class="p">&gt;</span>Second value<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;3&quot;</span><span class="p">&gt;</span>Third value<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&quot;4&quot;</span><span class="p">&gt;</span>Fourth value<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">optgroup</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">mkt-select</span><span class="p">&gt;</span>
</pre></div>


<p>What we'll do in the <code>createdCallback</code> is, if you check the source code,
create an actual internal hidden select element, copying the attributes
defined on <code>&lt;custom-select&gt;</code>. Then we'll create <code>&lt;custom-options&gt;</code>,
copying the original options into the hidden select. We extend the custom
select's interface to have an attribute pointing to the hidden select like so:</p>
<div class="highlight"><pre><span class="nx">select</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// Actual &lt;select&gt; element to proxy to, steal its interface.</span>
    <span class="c1">// Value set in the createdCallback.</span>
    <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_select</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">select</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">copyAttrs</span><span class="p">(</span><span class="nx">select</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_select</span> <span class="o">=</span> <span class="nx">select</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">},</span>
</pre></div>


<p>This will allow our custom element to <em>absorb</em> the functionality of the
native select element. All we have to do is implement the entire interface of
the select element by routing to the internal select element.</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">proxyInterface</span><span class="p">(</span><span class="nx">destObj</span><span class="p">,</span> <span class="nx">properties</span><span class="p">,</span> <span class="nx">methods</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Proxies destObj.&lt;properties&gt; and destObj.&lt;methods&gt;() to</span>
    <span class="c1">// destObj.&lt;key&gt;.</span>
    <span class="nx">properties</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">destObj</span><span class="p">,</span> <span class="nx">prop</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// Already defined.</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Set a property.</span>
        <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">destObj</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="p">{</span>
            <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">this</span><span class="p">[</span><span class="nx">key</span><span class="p">][</span><span class="nx">prop</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">});</span>

    <span class="nx">methods</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">method</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Set a method.</span>
        <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">destObj</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="p">{</span>
            <span class="nx">value</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">this</span><span class="p">[</span><span class="nx">key</span><span class="p">][</span><span class="nx">method</span><span class="p">].</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="nx">proxyInterface</span><span class="p">(</span><span class="nx">CustomSelectElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span>
    <span class="p">[</span><span class="s1">&#39;autofocus&#39;</span><span class="p">,</span> <span class="s1">&#39;disabled&#39;</span><span class="p">,</span> <span class="s1">&#39;form&#39;</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="s1">&#39;multiple&#39;</span><span class="p">,</span>
     <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;onchange&#39;</span><span class="p">,</span> <span class="s1">&#39;options&#39;</span><span class="p">,</span> <span class="s1">&#39;required&#39;</span><span class="p">,</span> <span class="s1">&#39;selectedIndex&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span>
     <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;validationMessage&#39;</span><span class="p">,</span> <span class="s1">&#39;validity&#39;</span><span class="p">,</span> <span class="s1">&#39;willValidate&#39;</span><span class="p">],</span>

    <span class="p">[</span><span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="s1">&#39;blur&#39;</span><span class="p">,</span> <span class="s1">&#39;checkValidity&#39;</span><span class="p">,</span> <span class="s1">&#39;focus&#39;</span><span class="p">,</span> <span class="s1">&#39;item&#39;</span><span class="p">,</span> <span class="s1">&#39;namedItem&#39;</span><span class="p">,</span>
     <span class="s1">&#39;remove&#39;</span><span class="p">,</span> <span class="s1">&#39;setCustomValidity&#39;</span><span class="p">],</span>

    <span class="s1">&#39;select&#39;</span><span class="p">);</span>
</pre></div>


<p><code>proxyInterface</code> will "route" the property lookups (the first array), and
method calls (the second array) from the custom select element to the internal
select element. Then all we need to do is make sure our select element's value
is up-to-date while we interact with our custom select element, then we can do
things like <code>customSelectElement.selectedIndex</code> or
<code>customSelectElement.checkValidity()</code> without manually implementing the
interface.</p>
<p>Note we could have simply looped over <code>HTMLSelectElement.prototype</code> rather
than manually entering in each property and method name, but unfortunately that
doesn't play well with some older browsers.</p>
<p>With all of this, we have a custom select element that is fully stylizable
while having all the functionality of a native select element (because it
extends it!).</p>
<h2 id="comparing-custom-elements-to-react">Comparing Custom Elements to React</h2>
<p>I love React and am using it for a couple of projects. How does Custom Elements
compare to it?</p>
<ol>
<li>
<p>Custom Elements has no answer to React's JSX template/syntax. In most of
our Custom Elements, we have to manually shuffle things around using the native
DOM API. JSX is much, much easier.</p>
</li>
<li>
<p>Custom Elements has no data-binding or automatic DOM updates whenever data
updates. It's all imperative with Custom Elements, you have to listen for changes
and manually update the DOM. React is, well, reactive. Whenever a component's
state, so does its representation in the DOM.</p>
</li>
<li>
<p>Custom Elements is a bit harder to nest components than React. In React,
it's natural for a component to render a component that renders a component
that renders other components. With Custom Elements, it's a bit difficult to
connect components together in a nice heirarchy, and the only communication
you get is through Events.</p>
</li>
<li>
<p>Custom Elements, however, is smaller in KB. React is about 26KB after
min+gzip whereas a Custom Elements polyfill is maybe a few KB. Though the 26KB
might be worth it since you'll end up writing less code, and you get the
performance of virtual DOM diffing.</p>
</li>
<li>
<p>Custom Elements has no answer to React Native.</p>
</li>
</ol>
<p>They're both just as portable, they both can be dropped into any framework.
They both have similar interfaces as well in creating components. Although,
React is more powerful. In React, I really enjoy keeping data compartmentalized
in states and passing down data as props. Loose comparison, but it's like
combining the data-binding and template power of Angular with the ideas of
Custom Elements.</p>
<p>However, it doesn't have to be one or the other either. Why not both? React can
wrap Custom Elements if you want it to. As always, choose the best tools for
the job.</p>
  </div>

  <p class="end-sect">&sect;</p>
  <div id="bottom-share" class="addthis_toolbox addthis_default_style">
  <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
  <a class="addthis_button_tweet"></a>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-513af3cd5e69b4ae"></script>
   <div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'ngokevin'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
           var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
           dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
           (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  <script src="https://cdn.jsdelivr.net/anchorjs/3.0.0/anchor.min.js"></script>
  <script>anchors.add('h2, h3, h4, h5, h6');</script>

      </div>
    </div>

    <div id="footer">
      <a href="mailto:me@ngokevin.com"><i class="fa fa-envelope"></i></a>
      <a href="http://twitter.com/ngokevin_"><i class="fa fa-twitter-square"></i></a>
      <a href="http://github.com/ngokevin"><i class="fa fa-github-square"></i></a>
      <a type="application/rss+xml" href="/rss/index.xml"><i class="fa fa-rss-square"></i></a>
    </div>

     <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29871909-1']);
  _gaq.push(['_trackPageview']);

  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
  </body>
</html>